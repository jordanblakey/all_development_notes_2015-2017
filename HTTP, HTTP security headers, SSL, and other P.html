<html>
<head>
  <title>HTTP, HTTP security headers, SSL, and other Protocols</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (en-US, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="7152"/>
<h1>HTTP, HTTP security headers, SSL, and other Protocols</h1>

<div>
<span><div><b>Everything you need to know about HTTP security headers</b></div><div>13 JANUARY 2017 on Security, Programming, Web</div><div>Some physicists 28 years ago needed a way to easily share experimental data and thus the web was born. This was generally considered to be a good move. Unfortunately, everything physicists touch — from trigonometry to the strong nuclear force — eventually becomes weaponized and so too has the Hypertext Transfer Protocol.</div><div><br/></div><ul><li>What can be attacked must be defended, and since tradition requires all security features to be a bolted-on afterthought, things… got a little complicated.</li><li>This article explains what secure headers are and how to implement these headers in Rails, Django, Express.js, Go, Nginx, and Apache.</li><li>Please note that some headers may be best configured in on your HTTP servers, while others should be set on the application layer. Use your own discretion here. You can test how well you’re doing with Mozilla’s Observatory.</li></ul><div><b><br/></b></div><hr/><div><b>HTTP Security Headers TOC</b></div><ul><li>X-XSS-Protection</li><li>Content Security Policy</li><li>HTTP Strict Transport Security (HSTS)</li><li>HTTP Public Key Pinning (HPKP)</li><li>X-Frame-Options</li><li>X-Content-Type-Options</li><li>Referrer-Policy</li><li>Cookie Options</li></ul><div><br/></div><hr/><div><b>X-XSS-Protection</b></div><div><br/></div><div>X-XSS-Protection: 0;<br/>
X-XSS-Protection: 1;<br/>
X-XSS-Protection: 1; mode=block<br/><br/></div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">Cross Site Scripting, commonly abbreviated XSS, is an attack where the attacker causes a page to load some malicious javascript. X-XSS-Protection is a feature in Chrome and Internet Explorer that is designed to protect against “reflected” XSS attacks — where an attacker is sending the malicious payload as part of the request1.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">X-XSS-Protection: 0 turns it off.</div><div style="margin-left:40px;">X-XSS-Protection: 1 will filter out scripts that came from the request - but will still render the page</div><div style="margin-left:40px;">X-XSS-Protection: 1; mode=block when triggered, will block the whole page from being rendered.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">Yes. Set X-XSS-Protection: 1; mode=block. The “filter bad scripts” mechanism is problematic; see here for why.</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">On by default</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">SECURE_BROWSER_XSS_FILTER = True</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Use unrolled/secure</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header X-XSS-Protection &quot;1; mode=block&quot;;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set X-XSS-Protection &quot;1; mode=block&quot;</div><div style="margin-left:40px;"><br/></div><hr/><div><b>Content Security Policy</b></div><div><br/></div><div>Content-Security-Policy: &lt;policy&gt;</div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">Content Security Policy can be thought of as much more advanced version of the X-XSS-Protection header above. While X-XSS-Protection will block scripts that come from the request, it’s not going to stop an XSS attack that involves storing a malicious script on your server or loading an external resource with a malicious script in it.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">CSP gives you a language to define where the browser can load resources from. You can white list origins for scripts, images, fonts, stylesheets, etc in a very granular manner. You can also compare any loaded content against a hash or signature.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">Yes. It won’t prevent all XSS attacks, but it’s a significant mitigation against their impact, and an important aspect of defense-in-depth. That said, it can be hard to implement. If you’re an intrepid reader and went ahead and checked the headers appcanary.com returns2, you’ll see that we don’t have CSP implemented yet. There are some rails development plugins we’re using that are holding us back from a CSP implementation that will have an actually security impact. We’re working on it, and will write about it in the next instalment!</div><div style="margin-left:40px;"><b><br/></b></div><div><b>How?</b></div><div style="margin-left:40px;">Writing a CSP policy can be challenging. See here for a list of all the directives you can employ. A good place to start is here.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">Use secureheaders</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">Use django-csp</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet/csp</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Use unrolled/secure</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header Content-Security-Policy &quot;&lt;policy&gt;&quot;;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set Content-Security-Policy &quot;&lt;policy&gt;&quot;</div><div style="margin-left:40px;"><b><br/></b></div><hr/><div><b>HTTP Strict Transport Security (HSTS)</b></div><div><br/></div><div>Strict-Transport-Security: max-age=&lt;expire-time&gt;<br/>
Strict-Transport-Security: max-age=&lt;expire-time&gt;; includeSubDomains<br/>
Strict-Transport-Security: max-age=&lt;expire-time&gt;; preload<br/><br/></div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">When we want to securely communicate with someone, we face two problems. The first problem is privacy; we want to make sure the messages we send can only be read by the recipient, and no one else. The other problem is that of authentication: how do we know the recipient is who they say they are?</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">HTTPS solves the first problem with encryption, though it has some major issues with authentication (more on this later, see Public Key Pinning). The HSTS header solves the meta-problem: how do you know if the person you’re talking to actually supports encryption?</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">HSTS mitigates an attack called sslstrip. Suppose you’re using a hostile network, where a malicious attacker controls the wifi router. The attacker can disable encryption between you and the websites you’re browsing. Even if the site you’re accessing is only available over HTTPS, the attacker can man-in-the-middle the HTTP traffic and make it look like the site works over unencrypted HTTP. No need for SSL certs, just disable the encryption.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Enter the HSTS. The Strict-Transport-Security header solves this by letting your browser know that it must always use encryption with your site. As long as your browser has seen an HSTS header — and it hasn’t expired — it will not access the site unencrypted, and will error out if it’s not available over HTTPS.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">Yes. Your app is only available over HTTPS, right? Trying to browse over regular old HTTP will redirect to the secure site, right? (Hint: Use letsencrypt if you want to avoid the racket that are commercial certificate authorities.)</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">The one downside of the HSTS header is that it allows for a clever technique to create supercookies that can fingerprint your users. As a website operator, you probably already track your users somewhat - but try to only use HSTS for good and not for supercookies.</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div><br/></div><div style="margin-left:40px;">The two options are</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">- includeSubDomains - HSTS applies to subdomains</div><div style="margin-left:40px;">- preload - Google maintains a service that hardcodes3 your site as being HTTPS only into browsers. This way, a user doesn’t even have to visit your site: their browser already knows it should reject unencrypted connections. Getting off that list is hard, by the way, so only turn it on if you know you can support HTTPS forever on all your subdomains.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Rails 4</b></div><div style="margin-left:40px;">config.force_ssl = true</div><div style="margin-left:40px;">Does not include subdomains by default. To set it:</div><div style="margin-left:40px;">config.ssl_options = { hsts: { subdomains: true } }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Rails 5</b></div><div style="margin-left:40px;">config.force_ssl = true</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">SECURE_HSTS_SECONDS = 31536000</div><div style="margin-left:40px;">SECURE_HSTS_INCLUDE_SUBDOMAINS = True</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Use unrolled/secure</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header Strict-Transport-Security &quot;max-age=31536000; includeSubdomains; &quot;;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set Strict-Transport-Security &quot;max-age=31536000; includeSubdomains;</div><div><br/></div><hr/><div><b>HTTP Public Key Pinning (HPKP)</b></div><div><br/></div><div>Public-Key-Pins: pin-sha256=&lt;base64==&gt;; max-age=&lt;expireTime&gt;;<br/>
Public-Key-Pins: pin-sha256=&lt;base64==&gt;; max-age=&lt;expireTime&gt;; includeSubDomains<br/>
Public-Key-Pins: pin-sha256=&lt;base64==&gt;; max-age=&lt;expireTime&gt;; report-uri=&lt;reportURI&gt;<br/><br/></div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">The HSTS header described above was designed to ensure that all connections to your website are encrypted. However, nowhere does it specify what key to use!</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Trust on the web is based on the certificate authority (CA) model. Your browser and operating system ship with the public keys of some trusted certificate authorities which are usually specialized companies and/or nation states. When a CA issues you a certificate for a given domain that means anyone who trusts that CA will automatically trust the SSL traffic you encrypt using that certificate. The CAs are responsible for verifying that you actually own a domain (this can be anything from sending an email, to asking you to host a file, to investigating your company).</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Two CAs can issue a certificate for the same domain to two different people, and browsers will trust both. This creates a problem, especially since CAs can be and arecompromised.  This allows attackers to MiTM any domain they want, even if that domain uses SSL &amp; HSTS!</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">The HPKP header tries to mitigate this. This header lets you to “pin” a certificate. When a browser sees the header for the first time, it will save the certificate. For every request up to max-age, the browser will fail unless at least one certificate in the chain sent from the server has a fingerprint that was pinned.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">This means that you can pin to the CA or a intermediate certificate along with the leaf in order to not shoot yourself in the foot (more on this later).</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Much like HSTS above, the HPKP header also has some privacy implications. These were laid out in the RFC itself.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">Probably not.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">HPKP is a very very sharp knife. Consider this: if you pin to the wrong certificate, or you lose your keys, or something else goes wrong, you’ve locked your users out of your site. All you can do is wait for the pin to expire.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">This article lays out the case against it, and includes a fun way for attackers to use HPKP to hold their victims ransom.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">One alternative is using the Public-Key-Pins-Report-Only header, which will just report that something went wrong, but not lock anyone out. This allows you to at least know your users are being MiTMed with fake certificates.</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div style="margin-left:40px;">The two options are</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">- includeSubDomains - HPKP applies to subdomains</div><div style="margin-left:40px;">- report-uri - Inavlid attempts will be reported here</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">You have to generate a base64 encoded fingerprint for the key you pin to, and you have to use a backup key. Check this guide for how to do it.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">Use secureheaders</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">Write custom middleware</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Use unrolled/secure</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header Public-Key-Pins 'pin-sha256=&quot;&lt;primary&gt;&quot;; pin-sha256=&quot;&lt;backup&gt;&quot;; max-age=5184000; includeSubDomains';</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set Public-Key-Pins 'pin-sha256=&quot;&lt;primary&gt;&quot;; pin-sha256=&quot;&lt;backup&gt;&quot;; max-age=5184000; includeSubDomains';</div><div style="margin-left:40px;"><b><br/></b></div><hr/><div><b>X-Frame-Options</b></div><div><br/></div><div>X-Frame-Options: DENY<br/>
X-Frame-Options: SAMEORIGIN<br/>
X-Frame-Options: ALLOW-FROM https://example.com/<br/><br/></div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">Before we started giving dumb names to vulnerabilities, we used to give dumb names to hacking techniques. “Clickjacking” is one of those dumb names.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">The idea goes like this: you create an invisible iframe, place it in focus and route user input into it. As an attacker, you can then trick people into playing a browser-based game while their clicks are being registered by a hidden iframe displaying twitter - forcing them to non-consensually retweet all of your tweets.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">It sounds dumb, but it’s an effective attack.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">Yes. Your app is a beautiful snowflake. Do you really want some genius shoving it into an iframe so they can vandalize it?</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div style="margin-left:40px;">X-Frame-Options has three modes, which are pretty self explanatory.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">- DENY - No one can put this page in an iframe</div><div style="margin-left:40px;">- SAMEORIGIN - The page can only be displayed in an iframe by someone on the same origin.</div><div style="margin-left:40px;">- ALLOW-FROM - Specify a specific url that can put the page in an iframe</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">One thing to remember is that you can stack iframes as deep as you want, and in that case, the behavior of SAMEORIGIN and ALLOW-FROM isn’t specified. That is, if we have a triple-decker iframe sandwich and the innermost iframe has SAMEORIGIN, do we care about the origin of the iframe around it, or the topmost one on the page? ¯\_(ツ)_/¯.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">SAMEORIGIN is set by default.</div><div style="margin-left:40px;">To set DENY:</div><div style="margin-left:40px;">config.action_dispatch.default_headers['X-Frame-Options'] = &quot;DENY&quot;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">MIDDLEWARE = [ ... 'django.middleware.clickjacking.XFrameOptionsMiddleware', ... ]</div><div style="margin-left:40px;">This defaults to SAMORIGIN.</div><div style="margin-left:40px;">To set DENY: X_FRAME_OPTIONS = 'DENY'</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Use unrolled/secure</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header X-Frame-Options &quot;deny&quot;;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set X-Frame-Options &quot;deny&quot;</div><div style="margin-left:40px;"><br/></div><hr/><div><b>X-Content-Type-Options</b></div><div>X-Content-Type-Options: nosniff;</div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">The problem this header solves is called “MIME sniffing”, which is actually a browser “feature”.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">In theory, every time your server responds to a request it is supposed to set a Content-Type header in order to tell the browser if it’s getting some HTML, a cat gif, or a Flash cartoon from 2008. Unfortunately, the web has always been broken and has never really followed a spec for anything; back in the day lots of people didn’t bother to set the content type header properly.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">As a result, browser vendors decided they should be really helpful and try to infer the content type by inspecting the content itself while completely ignore the content type header. If it looks like a gif, display a gif!, even though the content type is text/html. Likewise, if it looks like we got some HTML, we should render it as such even if the server said it’s a gif.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">This is great, except when you’re running a photo-sharing site, and users can upload photos that look like HTML with javascript included, and suddenly you have a stored XSS attack on your hand.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">The X-Content-Type-Options headers exist to tell the browser to shut up and set the damn content type to what I tell you, thank you.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">Yes, just make sure to set your content types correctly.</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div><br/></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">On by default</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">SECURE_CONTENT_TYPE_NOSNIFF = True</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Use unrolled/secure</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header X-Content-Type-Options nosniff;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set X-Content-Type-Options nosniff</div><div style="margin-left:40px;"><b><br/></b></div><hr/><div><b>Referrer-Policy</b></div><div><br/></div><div>Referrer-Policy: &quot;no-referrer&quot;<br/>
Referrer-Policy: &quot;no-referrer-when-downgrade&quot;<br/>
Referrer-Policy: &quot;origin&quot;<br/>
Referrer-Policy: &quot;origin-when-cross-origin&quot;<br/>
Referrer-Policy: &quot;same-origin&quot;<br/>
Referrer-Policy: &quot;strict-origin&quot;<br/>
Referrer-Policy: &quot;strict-origin-when-cross-origin&quot;<br/>
Referrer-Policy: &quot;unsafe-url&quot;<br/><br/></div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">Ah, the Referer header. Great for analytics, bad for your users’ privacy. At some point the web got woke and decided that maybe it wasn’t a good idea to send it all the time. And while we’re at it, let’s spell “Referrer” correctly4.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">The Referrer-Policy header allows you to specify when the browser will set a Refererheader.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">It’s up to you, but it’s probably a good idea. If you don’t care about your users’ privacy, think of it as a way to keep your sweet sweet analytics to yourself and out of your competitors’ grubby hands.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Set Referrer-Policy: &quot;no-referrer&quot;</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">Use secureheaders</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">Write custom middleware</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">Use helmet</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">Write custom middleware</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">add_header Referrer-Policy &quot;no-referrer&quot;;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">Header always set Referrer-Policy &quot;no-referrer&quot;</div><div><br/></div><hr/><div><b>Cookie Options</b></div><div><br/></div><div>Set-Cookie: &lt;key&gt;=&lt;value&gt;; Expires=&lt;expiryDate&gt;; Secure; HttpOnly; SameSite=strict</div><div><br/></div><div><b>Why?</b></div><div style="margin-left:40px;">This isn’t a security header per se, but there are three different options for cookies that you should be aware of.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">- Cookies marked as Secure will only be served over HTTPS. This prevents someone from reading the cookies in a MiTM attack where they can force the browser to visit a given page.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">- HttpOnly is a misnomer, and has nothing to do with HTTPS (unlike Secure above). Cookies marked as HttpOnly can not be accessed from within javascript. So if there is an XSS flaw, the attacker can’t immediately steal the cookies.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">- SameSite helps defend against Cross-Origin Request Forgery (CSRF) attacks. This is an attack where a different website the user may be visiting inadvertently tricks them into making a request against your site, i.e. by including an image to make a GET request, or using javascript to submit a form for a POST request. Generally, people defend against this using CSRF tokens. A cookie marked as SameSite won’t be sent to a different site.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">It has two modes, lax and strict. Lax mode allows the cookie to be sent in a top-level context for GET requests (i.e. if you clicked a link). Strict doesn’t send any third-party cookies.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">Should I use it?</div><div style="margin-left:40px;">You should absolutely set Secure and HttpOnly. Unfortunately, as of writing, SameSite cookies are available only in Chrome and Opera, so you may want to ignore them for now.</div><div style="margin-left:40px;"><br/></div><div><b>How?</b></div><div><br/></div><div style="margin-left:40px;"><b>Rails 4 and 5</b></div><div style="margin-left:40px;">Secure and HttpOnly enabled by default. For SameSite, use secureheaders</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Django</b></div><div style="margin-left:40px;">Session cookies are HttpOnly by default. To set secure: SESSION_COOKIE_SECURE = True.</div><div style="margin-left:40px;">Not sure about SameSite.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Express.js</b></div><div style="margin-left:40px;">cookie: { secure: true, httpOnly: true, sameSite: true }</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Go</b></div><div style="margin-left:40px;">http.Cookie{Name: &quot;foo&quot;, Value: &quot;bar&quot;, HttpOnly: true, Secure: true}</div><div style="margin-left:40px;">For SameSite, see this issue.</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Nginx</b></div><div style="margin-left:40px;">You probably won’t set session cookies in Nginx</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;"><b>Apache</b></div><div style="margin-left:40px;">You probably won’t set session cookies in Apache</div><div style="margin-left:40px;"><br/></div><hr/><div><b>Footnotes</b></div><div>- This is opposed to “stored” XSS attacks, where the attacker is storing the malicious payload somehow, i.e. in a vulnerable comment field of a message board. ↩</div><div>- If you’re going to point out in the Hacker News comments that this blog itself gets an F from the Mozilla observatory, you’re right! On the other hand, it’s serving static content, and we are comfortable avoiding XSS protection and strict SSL enforcement for static content. That, and it’s served by github pages/cloudflare, so it’s hard to get very granular about the headers we want set. ↩</div><div>- So if you’re especially paranoid, you might be thinking “what if I had some secret subdomain that I don’t want leaking for some reason?” You have DNS zone transfers disabled, so someone would have to know what they’re looking for to find it, but now that it’s in the preload list… ↩</div><div>- The Referer header is the Hampster Dance in that it’s notorious for being misspelled. It would break the web to try to backport the correct spelling, so instead the W3C decided to go for the worst of both worlds and spell it correctly in Referrer-Policy. ↩</div></span>
</div></body></html> 